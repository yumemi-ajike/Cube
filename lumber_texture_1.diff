diff --git a/Cube/CubeView.swift b/Cube/CubeView.swift
index 8ee4374..83bad5c 100644
--- a/Cube/CubeView.swift
+++ b/Cube/CubeView.swift
@@ -7,6 +7,7 @@
 //
 
 import UIKit
+import CoreGraphics
 
 final class CubeView: UIView {
     
@@ -18,22 +19,22 @@ final class CubeView: UIView {
     lazy var frontLayer: CALayer = {
         let transform = CATransform3DMakeTranslation(0, 0, size / 2)
         return createGradientFaceLayer(with: transform,
-                                       colors: [UIColor(white: 0.4, alpha: 1.0),
-                                                UIColor(white: 0.6, alpha: 1.0)])
+                                       colors: [UIColor(white: 0, alpha: 0.6),
+                                                UIColor(white: 0, alpha: 0.4)])
     }()
     lazy var rightLayer: CALayer = {
         var transform = CATransform3DMakeTranslation(size / 2, 0, 0)
         transform = CATransform3DRotate(transform, CGFloat.pi / 2 , 0, 1, 0)
         return createGradientFaceLayer(with: transform,
-                                       colors: [UIColor(white: 0.6, alpha: 1.0),
-                                                UIColor(white: 0.8, alpha: 1.0)])
+                                       colors: [UIColor(white: 0, alpha: 0.4),
+                                                UIColor(white: 0, alpha: 0.2)])
     }()
     lazy var topLayer: CALayer = {
         var transform = CATransform3DMakeTranslation(0, -size / 2, 0)
         transform = CATransform3DRotate(transform, CGFloat.pi / 2 , 1, 0, 0)
         return createGradientFaceLayer(with: transform,
-                                       colors: [UIColor(white: 1.0, alpha: 1.0),
-                                                UIColor(white: 0.8, alpha: 1.0)])
+                                       colors: [UIColor(white: 0, alpha: 0),
+                                                UIColor(white: 0, alpha: 0.2)])
     }()
     lazy var leftLayer: CALayer = {
         var transform = CATransform3DMakeTranslation(-size / 2, 0, 0)
@@ -257,6 +258,16 @@ final class CubeView: UIView {
         topLayer.addSublayer(topBottomLayer)
         topLayer.addSublayer(topRightLayer)
         topLayer.addSublayer(topLeftLayer)
+        
+        #if true
+        let intervals = self.intervals(side: size)
+        topLayer.contents = self.lumberTopImage(side: size, intervals: intervals)
+        frontLayer.contents = self.lumberSideImage(side: size, intervals: intervals, completion: { [weak self] remains in
+            guard let self = self, remains.isEmpty == false else { return }
+            
+            self.rightLayer.contents = self.lumberStrechImage(side: self.size, intervals: remains)
+        })
+        #endif
 
         baseLayer.addSublayer(frontLayer)
         baseLayer.addSublayer(rightLayer)
@@ -284,6 +295,7 @@ final class CubeView: UIView {
         gradientLayer.frame = CGRect(x: 0, y: 0, width: size, height: size)
         gradientLayer.colors = colors.map { $0.cgColor }
         layer.frame = CGRect(x: -size / 2, y: -size / 2, width: size, height: size)
+        layer.backgroundColor = UIColor.white.cgColor
         layer.cornerRadius = cornerRadius
         layer.masksToBounds = true
         layer.transform = transform
@@ -302,3 +314,112 @@ final class CubeView: UIView {
         return layer
     }
 }
+
+extension CubeView {
+    
+    struct Interval {
+        let distance: CGFloat
+        let width: CGFloat
+        let depth: CGFloat
+    }
+    
+    func intervals(side: CGFloat) -> [Interval] {
+        
+        var intervals: [Interval] = []
+        var maximum: CGFloat = 0
+        
+        repeat {
+            let distance = CGFloat(Float.random(in: 5 ... 30))
+            let width = CGFloat(Float.random(in: 2 ... 12))
+            let depth = CGFloat(Float.random(in: 0.2 ... 0.7))
+            if (maximum + distance + width / 2) < (side * sqrt(2)) {
+                intervals.append(Interval(distance: distance, width: width, depth: depth))
+                maximum += distance
+            } else {
+                intervals.append(Interval(distance: side - maximum, width: 0, depth: 0))
+                break
+            }
+            
+        } while(maximum < (side * sqrt(2)))
+        
+        return intervals
+    }
+    
+    func lumberTopImage(side: CGFloat, intervals: [Interval]) -> CGImage? {
+        
+        UIGraphicsBeginImageContext(CGSize(width: side, height: side))
+        guard let context = UIGraphicsGetCurrentContext() else { return nil }
+        
+        var radius: CGFloat = 0
+        intervals.forEach { interval in
+            radius += interval.distance
+            
+            context.setLineWidth(interval.width)
+            let startPoint = CGPoint(x: radius, y: side)
+            let endPoint = CGPoint(x: 0, y: side - radius)
+            context.move(to: startPoint)
+            context.addCurve(to: endPoint,
+                              control1: CGPoint(x: radius, y: side - radius),
+                              control2: endPoint)
+            context.setStrokeColor(UIColor(red: 1, green: 0, blue: 0, alpha: interval.depth).cgColor)
+            context.strokePath()
+        }
+        
+        return context.makeImage()
+    }
+    
+    func lumberSideImage(side: CGFloat, intervals: [Interval], completion: ([Interval]) -> Void) -> CGImage? {
+        
+        UIGraphicsBeginImageContext(CGSize(width: side, height: side))
+        guard let context = UIGraphicsGetCurrentContext() else { return nil }
+        
+        var remains: [Interval] = []
+        var pointer: CGFloat = 0
+        intervals.forEach { interval in
+            pointer += interval.distance
+            if pointer > side {
+                
+                let remain = Interval(distance: remains.count == 0 ? (pointer - side) : interval.distance,
+                                      width: interval.width,
+                                      depth: interval.depth)
+                remains.append(remain)
+            } else {
+                
+                context.setLineWidth(interval.width)
+                let startPoint = CGPoint(x: pointer, y: 0)
+                let endPoint = CGPoint(x: pointer, y: side)
+                context.move(to: startPoint)
+                context.addLine(to: endPoint)
+                context.setStrokeColor(UIColor(red: 1, green: 0, blue: 0, alpha: interval.depth).cgColor)
+                context.strokePath()
+            }
+        }
+        
+        completion(remains)
+        
+        return context.makeImage()
+    }
+    
+    func lumberStrechImage(side: CGFloat, intervals: [Interval]) -> CGImage? {
+        
+        UIGraphicsBeginImageContext(CGSize(width: side, height: side))
+        guard let context = UIGraphicsGetCurrentContext() else { return nil }
+        
+        let sum = intervals.reduce(0) { $0 + $1.distance }
+        let scale = side / sum
+        var pointer: CGFloat = 0
+        intervals.forEach { interval in
+            pointer += interval.distance * scale
+            
+            context.setLineWidth(interval.width * scale)
+            let startPoint = CGPoint(x: pointer, y: 0)
+            let endPoint = CGPoint(x: pointer, y: side)
+            context.move(to: startPoint)
+            context.addLine(to: endPoint)
+            context.setStrokeColor(UIColor(red: 1, green: 0, blue: 0, alpha: interval.depth).cgColor)
+            context.strokePath()
+        }
+        
+        return context.makeImage()
+    }
+}
